#' H2O Generalized Linear Models
#'
#' Fit a generalized linear model, specified by a response variable, a set of predictors, and a description of the error distribution.
#'
#' @param x
#' @param y
#' @param training_frame
#' @param ...
#' @param destination_key
#' @param validation_frame
#' @param max_iter
#' @param beta_eps
#' @param score_each_iteration
#' @param do_classification
#' @param balance_classes
#' @param class_sampling_factors
#' @param max_after_balance_size
#' @param solver
#' @param standardize
#' @param family
#' @param link
#' @param tweedie_variance_power
#' @param tweedie_link_power
#' @param alpha
#' @param lambda
#' @param prior1
#' @param lambda_search
#' @param nlambdas
#' @param lambda_min_ratio
#' @param higher_accuracy
#' @param use_all_factor_levels
#' @param n_folds

h2o.startGLMJob <- function(x, y, training_frame, destination_key, validation_frame, ...,
                    #AUTOGENERATED Params
                    max_iter = 50,
                    beta_eps = 0,
                    do_classification = FALSE,
                    balance_classes = FALSE,
                    class_sampling_factors,
                    max_after_balance_size = 5.0,
                    solver = c("ADMM", "L_BFGS"),
                    standardize = TRUE,
                    family = c("gaussian", "binomial", "poisson", "gamma", "tweedie"),
                    link = c("family_default", "identity", "logit", "log", "inverse", "tweedie"),
                    tweedie_variance_power = NaN,
                    tweedie_link_power = NaN,
                    alpha = 0.5,
                    prior1 = 0.0,
                    lambda = 1e-05,
                    lambda_search = FALSE,
                    nlambdas = -1,
                    lambda_min_ratio = 1.0,
                    use_all_factor_levels = FALSE,
                    n_folds = 0,
                    beta_constraint = NULL
                    )
{
    if (!is.null(beta_constraint)) {
        if (!inherits(beta_constraint, "data.frame") && !inherits(beta_constraint, "H2OFrame"))
          stop(paste("`beta_constraints` must be an H2OParsedData or R data.frame. Got: ", class(beta_constraint)))
        if (inherits(beta_constraint, "data.frame"))
          beta_constraint <- as.h2o(training_frame@conn, beta_constraint)
    }
    dots <- list(...)
  
    for(type in names(dots))
        if (is.environment(dots[[type]]))
        {
        dots$envir <- type
        type <- NULL
        } else {
          stop(paste0("\n  unused argument (", type, " = ", dots[[type]], ")"))
        }
    if (is.null(dots$envir)) 
        dots$envir <- parent.frame()

    if( missing(x) ) stop("`x` is missing, with no default")
    if( missing(y) ) stop("`y` is missing, with no default")
    if( missing(training_frame) ) stop("`training_frame` is missing, with no default")

    if (!inherits(training_frame, "H2OFrame"))
        tryCatch(training_frame <- h2o.getFrame(training_frame),
                 error = function(err) {
                   stop("argument \"training_frame\" must be a valid H2OFrame or key")
                })
#required map for params with different names, assuming it will change in the RESTAPI end
    .glm.map <- c("x" = "ignored_columns",
                "y" = "response_column",
                "key" = "destination_key")

    parms <- as.list(match.call(expand.dots = FALSE)[-1L])
    parms$... <- NULL

    args <- .verify_dataxy(training_frame, x, y)
    parms$x <- args$x_ignore
    parms$y <- args$y
    parms$training_frame  = training_frame
    parms$beta_constraint = beta_constraint
    names(parms) <- lapply(names(parms), function(i) { if (i %in% names(.glm.map)) i <- .glm.map[[i]]; i })
    .h2o.startModelJob(training_frame@conn, 'glm', parms, dots$envir)
}

h2o.getGLMModel <- function(keys) {
  job_key  <- keys[[1]]
  dest_key <- keys[[1]]
  .h2o.__waitOnJob(conn, job_key)
  model <- h2o.getModel(dest_key, conn)
  if (delete_train)
    h2o.rm(temp_train_key)
  if (!is.null(params$validation_frame))
    if (delete_valid)
      h2o.rm(temp_valid_key)
  model
}

h2o.glm <- function(x, y, training_frame, destination_key, validation_frame, 
                    #AUTOGENERATED Params
                    max_iter = 50,
                    beta_eps = 0,
                    score_each_iteration = FALSE,
                    do_classification = FALSE,
                    balance_classes = FALSE,
                    class_sampling_factors,
                    max_after_balance_size = 5.0,
                    solver = c("ADMM", "L_BFGS"),
                    standardize = TRUE,
                    family = c("gaussian", "binomial", "poisson", "gamma", "tweedie"),
                    link = c("family_default", "identity", "logit", "log", "inverse", "tweedie"),
                    tweedie_variance_power = NaN,
                    tweedie_link_power = NaN,
                    alpha = 0.5,
                    prior1 = 0.0,
                    lambda = 1e-05,
                    lambda_search = FALSE,
                    nlambdas = -1,
                    lambda_min_ratio = 1.0,
                    higher_accuracy = FALSE,
                    use_all_factor_levels = FALSE,
                    n_folds = 0,
                    beta_constraint = NULL,
                    ...
                    )
{
    if (!is.null(beta_constraint)) {
        if (!inherits(beta_constraint, "data.frame") && !inherits(beta_constraint, "H2OFrame"))
          stop(paste("`beta_constraints` must be an H2OParsedData or R data.frame. Got: ", class(beta_constraint)))
        if (inherits(beta_constraint, "data.frame"))
          beta_constraint <- as.h2o(training_frame@conn, beta_constraint)
    }
    dots <- list(...)
  
    for(type in names(dots))
        if (is.environment(dots[[type]]))
        {
        dots$envir <- type
        type <- NULL
        } else {
          stop(paste0("\n  unused argument (", type, " = ", dots[[type]], ")"))
        }
    if (is.null(dots$envir)) 
        dots$envir <- parent.frame()

    if( missing(x) ) stop("`x` is missing, with no default")
    if( missing(y) ) stop("`y` is missing, with no default")
    if( missing(training_frame) ) stop("`training_frame` is missing, with no default")

    if (!inherits(training_frame, "H2OFrame"))
        tryCatch(training_frame <- h2o.getFrame(training_frame),
                 error = function(err) {
                   stop("argument \"training_frame\" must be a valid H2OFrame or key")
                })
#required map for params with different names, assuming it will change in the RESTAPI end
    .glm.map <- c("x" = "ignored_columns",
                "y" = "response_column",
                "key" = "destination_key")

    parms <- as.list(match.call(expand.dots = FALSE)[-1L])
    parms$... <- NULL

    args <- .verify_dataxy(training_frame, x, y)
    parms$x <- args$x_ignore
    parms$y <- args$y    
    names(parms) <- lapply(names(parms), function(i) { if (i %in% names(.glm.map)) i <- .glm.map[[i]]; i })

    .h2o.createModel(training_frame@conn, 'glm', parms, dots$envir)
}
